### 1.路由组件怎么缓存

> 使用\<keep-alive>\</keep-alive>包裹该组件.  
> 退出时触发 deactivated 当再次进入（前进或者后退）时，只触发 activated

```
<keep-alive>
    <router-view></router-view>
</keep-alive>
```

### 2.cookie和session的区别

> 1. cookie数据存放在客户端的浏览器上，session存在在服务器上
> 2. cookie不安全，容易被人获取
> 3. session会在一定时间内保存在服务器上。当访问增多时，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie
> 4. 单个cookie保存的数据不能超过4K,很多浏览器都限制一个站点最多保存20个cookie  

> 存储在cookie中的数据，每次都会被浏览器自动放在http请求中  

```
document.cookie

//设置cookie属性
"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly"
```
- expires:过期时间(http/1.1中换成max-age)
- domian(域名)、path(路径)：决定cookie何时被浏览器添加到请求头部中(跨域问题)
- secure:设置cookie只有在确保安全的请求中才会发送
- httpOnly:设置cookie是否能通过js去访问(XSS攻击)

### 3.有几种跨域的方式，分别

> 1. jsonp:利用\<script>标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生JSON数据。JSONP请求一定需要对方的服务器做支持才可以。(仅支持get方法，会遭受XSS攻击)
> 2. cors:需要浏览器和后端同时支持，服务端设置**Access-Control-Allow-Origin**就可以开启CORS
> 3. nginx反向代理：通过nginx配置一个代理服务器(域名与domain1相同，端口不同)做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。
> 4. websocket:双向通信协议，在建立连接后，server与client都能主动向对方发送或接受数据。

### 4.实时刷新列表
> 1. 长轮询:客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
> 2. ajax轮询:让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。
> 3. 使用websocket：服务端就可以主动推送信息给客户端(只需要经过一次HTTP请求，就可以做到源源不断的信息传送了)  

**websocket: 通过单个tcp套接字在客户端和服务端间提供持续的实时通信**


### 5.事件绑定，考虑到性能页面优化的情况下，怎么绑定比较好

> 页面元素尽量使用事件代理，避免直接事件绑定。  
> 使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄漏及需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定。

```
//html
<table>
  <tr>
    <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>
  </tr>
  <tr>
    <td>...<strong>Northwest</strong>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
  <tr>...2 more lines of this kind...</tr>
  <tr>...2 more lines of this kind...</tr>
</table>

//js
let selectedTd;

table.onclick = function(event) {
  let target = event.target; // 在哪里单击的？

  if (target.tagName != 'TD') return; // 不在 TD 上？那么我们就不会在意

  highlight(target); // 高亮显示
};

function highlight(td) {
  if (selectedTd) { // 移除任何已存在的高亮显示内容
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // 高亮新的 td
}
```
算法：
1. 在容器上设置一个处理器。
2. 在处理器中 —— 检查源元素的 event.target。
3. 如果事件发生在我们感兴趣的元素中，那么处理该事件。  

好处：  
1. 简化初始化并节省内存：不需要添加许多处理器。
2. 更少的代码：添加或移除元素时，不需要添加/移除处理器。
3. DOM 修改 ：我们可以使用 innerHTML 等来大量添加/移除元素。  

局限性：  
1. 事件必须冒泡。而有些事件不会冒泡。
2. 委托会增加 CPU 负载，因为容器等级的处理器对容器中任何位置的事件做出反应，不管它们是否会引起我们的兴趣。但是通常负载是可以忽略不计的，所以我们不考虑它。

### 6.csrf攻击原理及怎么防范

> CSRF(Cross-site request forgery),"跨站请求伪造"，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。   
 
> CSRF攻击的三个必要条件
> 1. 目标站点一定要有CSRF漏洞
> 2. 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态
> 3. 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛  

> 防止攻击：  
> 1. 通常CSRF攻击都是从第三方站点发起的，要防止CSRF攻击，最好实现从第三方站点发送请求时禁止Cookie的发送。  
> Cookie的SameSite属性会决定是否发送cookie  
> 2. 在服务器端验证请求来源的站点
> 3. 在浏览器向服务器发起请求时，服务器生成一个CSRF Token。CSRF Token其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。在浏览器端如果要发起转账的请求，那么需要带上页面中的CSRF Token，然后服务器会验证该Token是否合法。如果是从第三方站点发起请求，那么将无法获取到CSRF Token的值，所以即使发起了请求，服务器也会因为CSRF Token不正确而拒绝请求。

token存放在session中

### 7.跨站脚本攻击(XSS)
> XSS(Cross Site Scripting)攻击是指黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段  
> 防范：服务器可以将某些Cookie设置为HttpOnly标志。由于JS无法读取设置了HttpOnly的Cookie数据，所以即使页面被注入了恶意Js脚本，也是无法获取到设置了HttpOnly的数据。

### 8.webpack怎么把css文件单独分离出来

> 在module中设置转换规则，test中设置匹配的路径正则表达式，include中设置文件路径，use中导入需要用到的loader

### 9.webpack的热更新怎么实现的

![](img/热更新原理.png)  

> 1. Webpack-dev-middleware调用webpack的API来监视文件系统。当文件更改时，webpack会重新编译和打包文件并将其保存到内存中。
> 2. devServer通知浏览器端文件更改。  
> 当启动devServer时，sockjs在服务器和浏览器之间建立长连接，以通知浏览器Webpack编译和打包各个阶段的状态。 最关键的一步是webpack-dev-server调用webpack API来侦听编译完成的事件。 编译完成后，webp Ack-dev-server通过_sendStatus方法将已编译并打包的新模块的哈希值发送到浏览器。
> 3. webpack-dev-server / client接收服务端消息并响应   
> Webpack-dev-server通过添加webpack-dev-client代码来修改webpack配置中的entry属性，以便将websocket消息的代码接收到最终的bundle.js文件中。  
> Webpack-dev-server / client收到类型为hash的消息时会临时保存哈希值，并在收到类型为ok的消息时重新加载应用程序。  
> 在重新加载操作中，webpack-dev-server / client会根据热配置决定是刷新浏览器还是热更新代码（HMR）。
> 4. webpack接收最新的散列值，验证并请求模块代码
> 5. 运行时热更新模块

### 10.tree shaking(摇树优化)

> tree shaking就是把模块中用到的方法打入bundle中，没用到的则在uglify阶段被擦除掉。

### 11.webpack第三方库

> 引入webpack,在plugins在引入webpack.ProvidePlugin插件，然后在其中设置第三方库，这样就会按需加载  

> 提取第三方库：把入口文件和第三方库分开，然后在optimization中设置缓存组和提取条件。

### 12.http与https

> https有加密，具有多路复用，可以减少队头阻塞，提高传输速度。

### 13.深拷贝

> 1. JSON对象的parse和stringify
> 2. 利用递归遍历，判断如果是引用类型则创建一个新对象，遍历后添加到这个上面

### 14.浅拷贝

> 1. Object.assign
> 2. 运算符...

### 15.Vue 和 React 之间的区别

> 1. 模板 vs JSX
> 2. 数据流

### 16.强制缓存与协商缓存的区别

> 1. 强缓存：浏览器再次加载资源时，如果在过期时间内，则命中强缓存。(浏览器直接从本地缓存中获取数据，不与服务器进行交互。)  
> state code为200.使用两种HTTP Header实现：Expires和Cache-Control(过期时间)
> 2. 协商缓存：如果缓存过期了，就需要发起请求验证资源是否有更新。(浏览器发送请求到服务器，服务器判断是否可使用本地缓存)通过设置两种HTTP Header:Last-Modified(资源的最后修改时间)和ETag(资源在服务器的唯一标识).  
> 当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回304状态码，并且更新浏览器缓存有效期。

### 17.节流
> 隔一段时间发起一次请求

### 18.防抖

> 当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求

### 19.哪些方式可以减少webpack的打包时间

> 1. 优化Loader,优化文件搜索范围
> 2. 代码压缩

### 20.减少Webpack打包后的文件体积

> 1. 按需加载：将每个路由页面单独打包为一个文件
> 2. Scope Hoisting:会分析出模块间的依赖关系，尽可能的把打包出来的模块合并到一个函数中。
> 3. Tree Shaking:删除项目中未被引用的代码。